Write an algorithm to determine if a number n is happy.
Example 1
Input: n = 19
Output: true
Example 2
Input: n = 2
Output: false

Happy Number Theorem:-

Starting with n, replace it with the sum of the squares of its digits, and repeat the process until n equals 1, or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are Happy Numbers, while those that do not end in 1 are unhappy numbers.
First few happy numbers are 1, 7, 10, 13, 19, 23, 28, 31, 32, 44, 49, 68, 70, 79, 82, 86, 91, 94, 97, 100

---------------------------------------------------------------------------------------------------------------------
    	C Code Implement for Happy Number
---------------------------------------------------------------------------------------------------------------------
#include<stdio.h>

int main()
{

	int n = 2 ,sum,rem;
    
	while(n>0)
	{
    	rem = n%10;
    	sum += rem * rem;
    	n=n/10;

    	if(n == 0 && sum >= 10)
    	{
        	n = sum;
        	sum = 0;
    	}
	}

	if(sum == 1){
    	printf("true");
	}else{
    	printf("false");
	}
}
---------------------------------------------------------------------------------------------------------------------
    	Assembly Code (Risc-V) Implement for Happy Number
---------------------------------------------------------------------------------------------------------------------

.data
	num: .word 19
	str1: .string "true"
	str2: .string "false"
    
.text
     main:
 	addi sp,sp,-16
 	sw ra,12(sp)
 	lw a3,num
 	li a2,10
 	li a1,9
	 
 exchange:
 	mv a4,a3
 	li a3,0
	 
 operation:
 	rem a5,a4,a2
 	div a4,a4,a2
 	mul a5,a5,a5
 	add a3,a3,a5
 	bne a4,zero,operation
 	bgt a3,a1,exchange
 	li a5,1	 
 	beq a3,a5,true
	 
 	la 	a0,str2	 
	 
 	li	a7,4
 	ecall
 	li  a7,10
 	ecall
 false:
 	lw ra,12(sp)
 	li a0,0
 	addi sp,sp,16
 	li a7,10
 	ecall
 	jr ra
 true:
 	la a0,str1
     	li a7,4
 	ecall
j     	false



---------------------------------------------------------------------------------------------------------------------
    	OPCODE(in hex + disassembled)
---------------------------------------------------------------------------------------------------------------------
00000000 <main>:
	0:    	ff010113    	addi x2 x2 -16
	4:    	00112623    	sw x1 12 x2
	8:    	10000697    	auipc x13 0x10000
	c:    	ff86a683    	lw x13 -8 x13
	10:    	00a00613    	addi x12 x0 10
	14:    	00900593    	addi x11 x0 9

00000018 <exchange>:
	18:    	00068713    	addi x14 x13 0
	1c:    	00000693    	addi x13 x0 0
00000020 <operation>:
	20:    	02c767b3    	rem x15 x14 x12
	24:    	02c74733    	div x14 x14 x12
	28:    	02f787b3    	mul x15 x15 x15
	2c:    	00f686b3    	add x13 x13 x15
	30:    	fe0718e3    	bne x14 x0 -16 <operation>
	34:    	fed5c2e3    	blt x11 x13 -28 <exchange>
	38:    	00100793    	addi x15 x0 1
	3c:    	02f68a63    	beq x13 x15 52 <true>
	40:    	10000517    	auipc x10 0x10000
	44:    	fc950513    	addi x10 x10 -55
	48:    	00400893    	addi x17 x0 4
	4c:    	00000073    	ecall
	50:    	00a00893    	addi x17 x0 10
	54:    	00000073    	ecall

00000058 <false>:
	58:    	00c12083    	lw x1 12 x2
	5c:    	00000513    	addi x10 x0 0
	60:    	01010113    	addi x2 x2 16
	64:    	00a00893    	addi x17 x0 10
	68:    	00000073    	ecall
	6c:    	00008067    	jalr x0 x1 0

00000070 <true>:
	70:    	10000517    	auipc x10 0x10000
	74:    	f9450513    	addi x10 x10 -108
	78:    	00400893    	addi x17 x0 4
	7c:    	00000073    	ecall
	80:    	fd9ff06f    	jal x0 -40 <false>

---------------------------------------------------------------------------------------------------------------------
    	OPCODE(in binary)
---------------------------------------------------------------------------------------------------------------------
00000000 <main>:
	0:    	ff010113    	11111111000000010000000100010011
	4:    	00112623    	00000000000100010010011000100011
	8:    	10000697    	00010000000000000000011010010111
	c:    	ff86a683    	11111111100001101010011010000011
	10:    	00a00613    	00000000101000000000011000010011
	14:    	00900593    	00000000100100000000010110010011

00000018 <exchange>:
	18:    	00068713    	00000000000001101000011100010011
	1c:    	00000693    	00000000000000000000011010010011

00000020 <operation>:
	20:    	02c767b3    	00000010110001110110011110110011
	24:    	02c74733    	00000010110001110100011100110011
	28:    	02f787b3    	00000010111101111000011110110011
	2c:    	00f686b3    	00000000111101101000011010110011
	30:    	fe0718e3    	11111110000001110001100011100011
	34:    	fed5c2e3    	11111110110101011100001011100011
	38:    	00100793    	00000000000100000000011110010011
	3c:    	02f68a63    	00000010111101101000101001100011
	40:    	10000517    	00010000000000000000010100010111
	44:    	fc950513    	11111100100101010000010100010011
	48:    	00400893    	00000000010000000000100010010011
	4c:    	00000073    	00000000000000000000000001110011
	50:    	00a00893    	00000000101000000000100010010011
	54:    	00000073    	00000000000000000000000001110011

00000058 <false>:
	58:    	00c12083    	00000000110000010010000010000011
	5c:    	00000513    	00000000000000000000010100010011
	60:    	01010113    	00000001000000010000000100010011
	64:    	00a00893    	00000000101000000000100010010011
	68:    	00000073    	00000000000000000000000001110011
	6c:    	00008067    	00000000000000001000000001100111

00000070 <true>:
	70:    	10000517    	00010000000000000000010100010111
	74:    	f9450513    	11111001010001010000010100010011
	78:    	00400893    	00000000010000000000100010010011
	7c:    	00000073    	00000000000000000000000001110011
	80:    	fd9ff06f    	11111101100111111111000001101111
